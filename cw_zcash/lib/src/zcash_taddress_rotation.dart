// create offset wallets for T address rotation.
// Each address is considered one time use, if it receives less than 15000 zatoshi balance will be essentially burned.
//
// This class takes address index as constructor, and will create 10 addresses by default, if any of the addresses gets used
// it will be moved out of the pool
//
// T addresses are generated by creating new wallets with an extra seed word (or appending to "passphrase") the following
// :tgen:${CRC32(seed)}:${accountIndex}
// It is highly unlikely for users to create a wallet with that specific last word
// We could leverage other fields such as native account index, but users may want to set that in future
// This solution is rather simple and if standard would get estabilished for this purpose it can be easily
// turned off and replaced with proper solution.
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:cw_core/pathForWallet.dart';
import 'package:cw_core/utils/print_verbose.dart';
import 'package:cw_core/wallet_type.dart';
import 'package:cw_zcash/src/util/crc32.dart';
import 'package:cw_zcash/src/zcash_wallet.dart';
import 'package:cw_zcash/src/zcash_wallet_service.dart';
import 'package:flutter/services.dart';
import 'package:warp_api/data_fb_generated.dart';
import 'package:warp_api/warp_api.dart';
import 'package:flat_buffers/flat_buffers.dart' as fb;
import 'package:path/path.dart' as p;

class ZcashTaddressRotation {
  ZcashTaddressRotation(this.accountIndex);
  final int accountIndex;

  static bool _isStarted = false;

  static const coin = ZcashWalletBase.coin;
  static String seedForOffset(final String seed, final int accountIndex) {
    final seedWords = seed.split(" ");
    if ([12, 24].contains(seedWords.length)) {
      seedWords.add("");
    }
    final lastI = seedWords.length - 1;
    final crc = CRC32.compute(seed);
    seedWords[lastI] += ":tgen:${crc}:${accountIndex}";
    return seedWords.join(" ");
  }

  static Map<String, List<Account>> rotationAccounts = {};
  static Map<String, List<Account>> rotationAccountsUsable = {};
  static Map<int, List<ShieldedTx>> shieldedAccountsTx = {};
  static Future<void> init() async {
    if (_isStarted) {
      return;
    }
    _isStarted = true;
    final pfw = await pathForWalletTypeDir(type: WalletType.zcash);
    try {
      final f = File(p.join(pfw,"zec-taddr.json"));
      if (!f.existsSync()) {
        f.writeAsBytesSync(serialize());
      }
      deserialize(f.readAsBytesSync());
    } catch (e) {
      printV("Failed to deserialize T address DB for zcash, it doesn't really matter: $e");
    }

    unawaited(
      (() async {
        await Future.delayed(Duration(seconds: 5));
        return _jobRunner();
      })(),
    );
  }
  
  static Future<void> serializeToFile() async {
    final pfw = await pathForWalletTypeDir(type: WalletType.zcash);
    final f = File(p.join(pfw,"zec-taddr.json"));
    f.writeAsBytesSync(serialize());
  }

  static Uint8List serialize() {
    final data = {
      "rotationAccounts": rotationAccounts.map(
        (final k, final v) => MapEntry(
          k,
          v.map((final a) => _flatBuffersPack(a.unpack().pack)).toList(),
        ),
      ),
      "rotationAccountsUsable": rotationAccountsUsable.map(
        (final k, final v) => MapEntry(
          k,
          v.map((final a) => _flatBuffersPack(a.unpack().pack)).toList(),
        ),
      ),
      "shieldedAccountsTx": shieldedAccountsTx.map(
        (final k, final v) => MapEntry(
          k.toString(),
          v.map((final a) => _flatBuffersPack(a.unpack().pack)).toList(),
        ),
      )
    };
    
    return utf8.encode(jsonEncode(data));
  }
  
  static String _flatBuffersPack(final int Function(fb.Builder fbBuilder) pack) {
    final fbBuilder = fb.Builder();
    final offset = pack(fbBuilder);
    fbBuilder.finish(offset);
    return base64.encode(fbBuilder.buffer);
  }

  static Map<String, Map<dynamic, List<dynamic>>> deserialize(final Uint8List bytes) {
    try {
      final Map<dynamic, dynamic> data = jsonDecode(utf8.decode(bytes));
      return {
        "rotationAccounts": (data["rotationAccounts"] as Map<String, dynamic>).map(
          (final k, final v) =>
              MapEntry(k, (v as List).map((final a) => Account(atob(a))).toList()),
        ),
        "rotationAccountsUsable": (data["rotationAccountsUsable"] as Map<String, dynamic>).map(
          (final k, final v) =>
              MapEntry(k, (v as List).map((final a) => Account(atob(a))).toList()),
        ),
        "shieldedAccountsTx": (data["shieldedAccountsTx"] as Map<String, dynamic>).map(
          (final k, final v) =>
              MapEntry(int.parse(k), (v as List).map((final a) => ShieldedTx(atob(a))).toList()),
        ),
      };
    } catch (e) {
      return {};
    }
  }

  static Uint8List atob(final String value) => Uint8List.fromList(List<int>.from(base64.decode(value)));

  static Future<void> createAndSweepTAddresses() async {
    final chainHeight = await WarpApi.getLatestHeight(coin);
    final dbHeight = WarpApi.getDbHeight(coin);
    final height = dbHeight.unpack();
    final syncHeight = height.height;
    if (chainHeight != syncHeight) {
      printV("Waiting for sync to finish: chainHeight(${chainHeight}) != syncHeight(${syncHeight})");
      return;
    }
    final Map<int, List<ShieldedTx>> newShieldedAccountsTx = {};
    final accounts = WarpApi.getAccountList(coin);
    if (accounts.isEmpty) return;
    final List<String> seeds = [];
    for (int i = 0; i < accounts.length; i++) {
      final acc = accounts[i];
      final backup = WarpApi.getBackup(coin, acc.id);
      await WarpApi.transparentSync(coin, acc.id, syncHeight);
      seeds.add(backup.seed!);
    }
    seeds.sort();
    seeds.sort((final String a, final String b) => a.length.compareTo(b.length));
    for (int i = 0; i < seeds.length; i++) {
      final seed = seeds[i];
      if ([12, 13, 24, 25].contains(seed.split(" ").length)) {
        if (seed.split(" ").last.contains(":tgen:")) continue;
        rotationAccounts[seed] = [];
      }
    }
    final raKeys = rotationAccounts.keys.toList();
    seeds.removeWhere(raKeys.contains);
    printV("raKeys: ${raKeys.length}");
    for (int i = 0; i < raKeys.length; i++) {
      final accs = accounts.where((final a) {
        final seed = WarpApi.getBackup(coin, a.id).seed;
        final t1 = seed?.startsWith(raKeys[i]) == true;
        final t2 = !raKeys.contains(seed);
        return t1 && t2;
      }).toList();
      rotationAccounts[raKeys[i]]!.addAll(accs);
    }
    rotationAccountsUsable = rotationAccounts.map((final k, final v) => MapEntry(k, v.toList()));
    printV("rotationAccounts: ${rotationAccounts.length}");

    for (int i = 0; i < raKeys.length; i++) {
      final acc = accountForSeed(raKeys[i])!;
      newShieldedAccountsTx[acc.id] = [];
      rotationAccountsUsable[raKeys[i]]!.removeWhere((final a) {
        final txs = WarpApi.getTxsSync(coin, a.id);
        newShieldedAccountsTx[acc.id]!.addAll(txs);
        return txs.isNotEmpty;
      });
    }
    printV("rotationAccountsUsable: ${rotationAccountsUsable.length}");

    bool didAddNewAccount = false;
    for (int i = 0; i < raKeys.length; i++) {
      if (rotationAccountsUsable[raKeys[i]]!.length == 0) {
        final name = CRC32.compute(raKeys[i]).toString();
        final seed = seedForOffset(raKeys[i], rotationAccounts[raKeys[i]]!.length);
        final id = await ZcashWalletService.runInDbMutex(() => WarpApi.newAccount(coin, name, seed, 0));
        printV("new id: $id / $seed");
        printV("${rotationAccounts[raKeys[i]]}");
        printV(raKeys[i]);
        rotationAccounts[raKeys[i]]!.forEach((final a) {
          final b = WarpApi.getBackup(coin, a.id);
          printV("${a.id} / ${b.seed}");
        });
        didAddNewAccount = true;
      }
    }
    printV("didAddNewAccount: ${didAddNewAccount}");
    if (didAddNewAccount) {
      return createAndSweepTAddresses();
    }

    for (var i = 0; i < raKeys.length; i++) {
      final accs = rotationAccounts[raKeys[i]]!;
      inner:
      for (var j = 0; j < accs.length; j++) {
        final bal = await WarpApi.getTBalance(coin, accs[j].id);
        if (bal < 30000) continue inner;
        final to = accountForSeed(raKeys[i])!;
        // final toAddress = WarpApi.getTAddr(coin, to.id);
        // final fromSeed = WarpApi.getBackup(coin, to.id);
        // final txId = await ZcashWalletService.runInDbMutex(
        //   () => WarpApi.sweepTransparentSeed(
        //     to.coin,
        //     to.id,
        //     chainHeight,
        //     fromSeed.seed!,
        //     7,
        //     toAddress,
        //     0,
        //     1,
        //     FeeT(fee: 10000, minFee: 0, maxFee: 0, scheme: 0),
        //   ),
        // );
        final recipientBuilder = RecipientObjectBuilder(
          address: WarpApi.getAddress(coin, to.id, 4),
          pools: 4,
          feeIncluded: true,
          amount: bal,
        );

        final recipient = Recipient(recipientBuilder.toBytes());
        final fee = FeeT(fee: 10000, minFee: 0, maxFee: 0, scheme: 0);
        final txPlan = await ZcashWalletService.runInDbMutex(
          () => WarpApi.prepareTx(
            coin,
            accs[j].id,
            [recipient],
            3, // pools: (Transparent + Sapling)
            1,
            0, // anchorOffset
            fee,
          ),
        );
        final _txId = await ZcashWalletService.runInDbMutex(
          () => WarpApi.signAndBroadcast(ZcashWalletBase.coin, accs[j].id, txPlan),
        );
        await ZcashWalletService.addShieldedTx(_txId);
        printV("shielded: $_txId");

        await Future.delayed(Duration(seconds: 120)); // let it be
        return createAndSweepTAddresses();
      }
    }
    final nsatKeys = newShieldedAccountsTx.keys.toList();
    for (int i = 0; i < nsatKeys.length; i++) {
      inner:
      for (int j = 0; j < newShieldedAccountsTx[nsatKeys[i]]!.length; j++) {
        final tx = newShieldedAccountsTx[nsatKeys[i]]?[j];
        if (tx == null) {
          continue inner;
        }
        final _txId = tx.txId;
        if (_txId == null) {
          continue inner;
        }
        printV("newtx: $tx");
        if (tx.value > 0) {
          continue inner;
        }
        if (ZcashWalletService.autoshieldTx.contains(_txId)) {
          continue inner;
        }
        await ZcashWalletService.addShieldedTx(_txId);
      }
    }
    shieldedAccountsTx = newShieldedAccountsTx.map((final k, final v) => MapEntry(k, v));
    await serializeToFile();
    return;
  }

  static Account? accountForSeed(final String seed) {
    final accounts = WarpApi.getAccountList(coin);
    if (accounts.isEmpty) return null;
    for (int i = 0; i < accounts.length; i++) {
      final acc = accounts[i];
      final backup = WarpApi.getBackup(coin, acc.id);
      if (backup.seed == seed) {
        return acc;
      }
    }
    return null;
  }

  static Future<void> _jobRunner() async {
    for (;;) {
      try {
        await Future.delayed(Duration(seconds: 5));
        await createAndSweepTAddresses();
      } catch (e, s) {
        printV(e);
        s.toString().split("\n").forEach(printV);
        rethrow;
      } finally {
        await Future.delayed(Duration(seconds: 30));
      }
    }
  }

  static String? addressForAccount(final int accountId) {
    final seed = WarpApi.getBackup(coin, accountId).seed!;
    final acc = rotationAccountsUsable[seed]?.firstOrNull;
    printV("addressForAccount: ${rotationAccountsUsable[seed]}");
    printV("addressForAccount: $seed");
    printV("addressForAccount: $acc");
    printV("addressForAccount: ${rotationAccountsUsable.keys}");
    if (acc == null) {
      return null;
    }
    return WarpApi.getTAddr(coin, acc.id);
  }
}
