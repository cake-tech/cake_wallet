// create offset wallets for T address rotation.
// Each address is considered one time use, if it receives less than 15000 zatoshi balance will be essentially burned.
//
// This class takes address index as constructor, and will create 10 addresses by default, if any of the addresses gets used
// it will be moved out of the pool
//
// T addresses are generated by creating new wallets with an extra seed word (or appending to "passphrase") the following
// :tgen:${CRC32(seed)}
// It is highly unlikely for users to create a wallet with that specific last word and add index to it
// We could leverage other fields such as native account index alone, but users may want to set that in future
// This solution is rather simple and if standard would get estabilished for this purpose it can be easily
// turned off and replaced with proper solution.

import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:cw_core/pathForWallet.dart';
import 'package:cw_core/utils/print_verbose.dart';
import 'package:cw_core/wallet_type.dart';
import 'package:cw_zcash/src/util/crc32.dart';
import 'package:cw_zcash/src/zcash_wallet.dart';
import 'package:cw_zcash/src/zcash_wallet_service.dart';
import 'package:flutter/foundation.dart';
import 'package:warp_api/data_fb_generated.dart';
import 'package:warp_api/warp_api.dart';
import 'package:flat_buffers/flat_buffers.dart' as fb;
import 'package:path/path.dart' as p;

class ZcashTaddressRotation {
  ZcashTaddressRotation(this.accountIndex);
  final int accountIndex;

  static bool _isStarted = false;

  static const coin = ZcashWalletBase.coin;
  static String seedForOffset(final String seed) {
    final seedWords = seed.split(" ");
    if ([12, 24].contains(seedWords.length)) {
      seedWords.add("");
    }
    final lastI = seedWords.length - 1;
    final crc = CRC32.compute(seed);
    seedWords[lastI] += ":tgen:${crc}";
    return seedWords.join(" ");
  }

  static bool isSeedForWallet(final String mainWallet, final String subWallet) {
    return seedForOffset(mainWallet.trim()) == subWallet;
  }

  static Map<int, List<Account>> rotationAccounts = {};
  static Map<int, List<Account>> rotationAccountsUsable = {};
  static Map<int, List<ShieldedTx>> shieldedAccountsTx = {};
  static Future<void> init() async {
    printV("Deserializing previous state");
    if (_isStarted) {
      return;
    }
    _isStarted = true;
    final pfw = await pathForWalletTypeDir(type: WalletType.zcash);
    try {
      final f = File(p.join(pfw, "zec-taddr.json"));
      if (!f.existsSync()) {
        f.writeAsBytesSync(serialize());
      }
      deserialize(f.readAsBytesSync());
    } catch (e) {
      printV("Failed to deserialize T address DB for zcash, it doesn't really matter: $e");
    }

    unawaited(
      (() async {
        await Future.delayed(Duration(seconds: 5));
        return _jobRunner();
      })(),
    );
  }

  static Future<void> serializeToFile() async {
    final pfw = await pathForWalletTypeDir(type: WalletType.zcash);
    final f = File(p.join(pfw, "zec-taddr.json"));
    f.writeAsBytesSync(serialize());
  }

  static Uint8List serialize() {
    final data = {
      "rotationAccounts": rotationAccounts.map(
        (final k, final v) =>
            MapEntry(k.toRadixString(16), v.map((final a) => flatBuffersPack(a.unpack().pack)).toList()),
      ),
      if (kDebugMode)
        "_rotationAccounts": rotationAccounts.map(
          (final k, final v) => MapEntry(k.toRadixString(16), v.map((final a) => a.toString()).toList()),
        ),
      "rotationAccountsUsable": rotationAccountsUsable.map(
        (final k, final v) =>
            MapEntry(k.toRadixString(16), v.map((final a) => flatBuffersPack(a.unpack().pack)).toList()),
      ),
      if (kDebugMode)
        "_rotationAccountsUsable": rotationAccountsUsable.map(
          (final k, final v) => MapEntry(k.toRadixString(16), v.map((final a) => a.toString()).toList()),
        ),
      "shieldedAccountsTx": shieldedAccountsTx.map(
        (final k, final v) =>
            MapEntry(k.toRadixString(16), v.map((final a) => flatBuffersPack(a.unpack().pack)).toList()),
      ),
      if (kDebugMode)
        "_shieldedAccountsTx": shieldedAccountsTx.map(
          (final k, final v) => MapEntry(k.toRadixString(16), v.map((final a) => a.toString()).toList()),
        ),
    };

    if (kDebugMode) {
      return utf8.encode(JsonEncoder.withIndent("    ").convert(data));
    }
    return utf8.encode(jsonEncode(data));
  }

  static String flatBuffersPack(final int Function(fb.Builder fbBuilder) pack) {
    final fbBuilder = fb.Builder();
    final offset = pack(fbBuilder);
    fbBuilder.finish(offset);
    return base64.encode(fbBuilder.buffer);
  }

  static void deserialize(final Uint8List bytes) {
    // todo: replace keys with sums and reverse in serialize
    // final List<String> seeds = [];
    // for (int i = 0; i < accounts.length; i++) {
    //   final acc = accounts[i];
    //   final backup = WarpApi.getBackup(coin, acc.id);
    //   await WarpApi.transparentSync(coin, acc.id, syncHeight);
    //   seeds.add(backup.seed!);
    // }
    try {
      final Map<dynamic, dynamic> data = jsonDecode(utf8.decode(bytes));
      rotationAccounts = (data["rotationAccounts"] as Map<String, dynamic>).map(
        (final k, final v) => MapEntry(int.parse(k, radix: 16), (v as List).map((final a) => Account(atob(a))).toList()),
      );
      rotationAccountsUsable = (data["rotationAccountsUsable"] as Map<String, dynamic>).map(
        (final k, final v) => MapEntry(int.parse(k, radix: 16), (v as List).map((final a) => Account(atob(a))).toList()),
      );
      shieldedAccountsTx = (data["shieldedAccountsTx"] as Map<String, dynamic>).map(
        (final k, final v) => MapEntry(int.parse(k, radix: 16), (v as List).map((final a) => ShieldedTx(atob(a))).toList()),
      );
    } catch (e) {
      rethrow;
    }
  }

  static Uint8List atob(final String value) => Uint8List.fromList(List<int>.from(base64.decode(value)));

  static Future<void> createAndSweepTAddresses() async {
    int chainHeight = 0;
    try {
      chainHeight = await WarpApi.getLatestHeight(coin);
    } catch (e) {
      printV("Error getting latest height: $e");
    }
    final dbHeight = WarpApi.getDbHeight(coin);
    final height = dbHeight.unpack();
    final syncHeight = height.height;
    if (chainHeight != syncHeight) {
      printV("Waiting for sync to finish: chainHeight(${chainHeight}) != syncHeight(${syncHeight})");
      return;
    }
    final Map<int, List<ShieldedTx>> newShieldedAccountsTx = {};
    final accounts = WarpApi.getAccountList(coin);
    if (accounts.isEmpty) return;
    final Map<int, String> seeds = {};
    for (int i = 0; i < accounts.length; i++) {
      final acc = accounts[i];
      final backup = WarpApi.getBackup(coin, acc.id);
      await WarpApi.transparentSync(coin, acc.id, syncHeight);
      seeds[acc.id] = backup.seed!;
    }
    for (int i = 0; i < accounts.length; i++) {
      final seed = seeds[accounts[i].id]!;
      if ([12, 13, 24, 25].contains(seed.split(" ").length)) {
        if (seed.split(" ").last.contains(":tgen:")) continue;
        rotationAccounts[accounts[i].id] = [];
      }
    }
    final raKeys = rotationAccounts.keys.toList();
    seeds.removeWhere((_, final val) => raKeys.contains(val));
    printV("raKeys: ${raKeys.length}");
    for (int i = 0; i < raKeys.length; i++) {
      final accs = accounts.where((final a) {
        final seed = WarpApi.getBackup(coin, a.id).seed;
        return isSeedForWallet(seeds[raKeys[i]]!, seed!);
      }).toList();
      rotationAccounts[raKeys[i]]!.addAll(accs);
      final acc = accountForSeed(seeds[raKeys[i]]!)!;
      final txs = WarpApi.getTxsSync(coin, acc.id);
      newShieldedAccountsTx[acc.id] ??= [];
      newShieldedAccountsTx[acc.id]!.addAll(txs);
    }
    rotationAccountsUsable = rotationAccounts.map((final k, final v) => MapEntry(k, v.toList()));
    printV("rotationAccounts: ${rotationAccounts.length}");

    for (int i = 0; i < raKeys.length; i++) {
      final acc = accountForSeed(seeds[raKeys[i]]!)!;
      newShieldedAccountsTx[acc.id] = [];
      for (int j = 0; j < (rotationAccounts[raKeys[i]]?.length ?? 0); j++) {
        final txs = WarpApi.getTxsSync(coin, rotationAccounts[raKeys[i]]![j].id);
        rotationAccounts[raKeys[i]]![j];
        newShieldedAccountsTx[acc.id]!.addAll(txs);
      }
      rotationAccountsUsable[raKeys[i]]!.removeWhere((final a) {
        final txs = WarpApi.getTxsSync(coin, a.id);
        return txs.isNotEmpty;
      });
    }
    printV("rotationAccountsUsable: ${rotationAccountsUsable.length}");

    bool didAddNewAccount = false;
    for (int i = 0; i < raKeys.length; i++) {
      if (rotationAccountsUsable[raKeys[i]]!.length < 5) {
        final seed = seedForOffset(seeds[raKeys[i]]!);
        final name = CRC32.compute(raKeys[i].toString()).toString();
        final id = await ZcashWalletService.runInDbMutex(
          () => WarpApi.newAccount(coin, name, seed, rotationAccounts[raKeys[i]]!.length),
        );
        printV("new id: $id / $seed");
        printV("${rotationAccounts[raKeys[i]]}");
        printV(raKeys[i]);
        rotationAccounts[raKeys[i]]!.forEach((final a) {
          final b = WarpApi.getBackup(coin, a.id);
          printV("${a.id} / ${b.seed}");
        });
        didAddNewAccount = true;
      }
    }
    printV("didAddNewAccount: ${didAddNewAccount}");
    if (didAddNewAccount) {
      return createAndSweepTAddresses();
    }

    for (var i = 0; i < raKeys.length; i++) {
      final accs = rotationAccounts[raKeys[i]]!;
      inner:
      for (var j = 0; j < accs.length; j++) {
        final bal = await WarpApi.getTBalance(coin, accs[j].id);
        if (bal < 30000) continue inner;
        final to = accountForSeed(seeds[raKeys[i]]!)!;
        // final toAddress = WarpApi.getTAddr(coin, to.id);
        // final fromSeed = WarpApi.getBackup(coin, to.id);
        // final txId = await ZcashWalletService.runInDbMutex(
        //   () => WarpApi.sweepTransparentSeed(
        //     to.coin,
        //     to.id,
        //     chainHeight,
        //     fromSeed.seed!,
        //     7,
        //     toAddress,
        //     0,
        //     1,
        //     FeeT(fee: 10000, minFee: 0, maxFee: 0, scheme: 0),
        //   ),
        // );
        final recipientBuilder = RecipientObjectBuilder(
          address: WarpApi.getAddress(coin, to.id, 4),
          pools: 4,
          feeIncluded: true,
          amount: bal,
        );

        final recipient = Recipient(recipientBuilder.toBytes());
        final fee = FeeT(fee: 10000, minFee: 0, maxFee: 0, scheme: 0);
        final txPlan = await ZcashWalletService.runInDbMutex(
          () => WarpApi.prepareTx(
            coin,
            accs[j].id,
            [recipient],
            3, // pools: (Transparent + Sapling)
            1,
            0, // anchorOffset
            fee,
          ),
        );
        final _txId = await ZcashWalletService.runInDbMutex(
          () => WarpApi.signAndBroadcast(ZcashWalletBase.coin, accs[j].id, txPlan),
        );
        await ZcashWalletService.addShieldedTx(_txId);
        printV("shielded: $_txId");

        await Future.delayed(Duration(seconds: 120)); // let it be
        return createAndSweepTAddresses();
      }
    }
    final nsatKeys = newShieldedAccountsTx.keys.toList();
    for (int i = 0; i < nsatKeys.length; i++) {
      inner:
      for (int j = 0; j < newShieldedAccountsTx[nsatKeys[i]]!.length; j++) {
        final tx = newShieldedAccountsTx[nsatKeys[i]]?[j];
        if (tx == null) {
          continue inner;
        }
        final _txId = tx.txId;
        if (_txId == null) {
          continue inner;
        }
        if (tx.value < 0) {
          await ZcashWalletService.addShieldedTx(_txId);
          // continue inner;
        }
        if (ZcashWalletService.autoshieldTx.contains(_txId)) {
          continue inner;
        }
      }
    }
    shieldedAccountsTx = newShieldedAccountsTx.map((final k, final v) => MapEntry(k, v.toList()));
    await serializeToFile();
    return;
  }

  static ShieldedTx reverseAmount(final ShieldedTx t) {
    final tt = t.unpack();
    tt.value = -tt.value;
    return ShieldedTx(base64.decode(flatBuffersPack(tt.pack)));
  }

  static Account? accountForSeed(final String seed) {
    final accounts = WarpApi.getAccountList(coin);
    if (accounts.isEmpty) return null;
    for (int i = 0; i < accounts.length; i++) {
      final acc = accounts[i];
      final backup = WarpApi.getBackup(coin, acc.id);
      if (backup.seed == seed) {
        return acc;
      }
    }
    return null;
  }

  static Future<void> _jobRunner() async {
    for (;;) {
      try {
        await Future.delayed(Duration(seconds: 5));
        await createAndSweepTAddresses();
      } catch (e, s) {
        printV(e);
        s.toString().split("\n").forEach(printV);
        rethrow;
      } finally {
        await Future.delayed(Duration(seconds: 30));
      }
    }
  }

  static String? addressForAccount(final int accountId) {
    final acc = rotationAccountsUsable[accountId]?.firstOrNull;
    if (acc == null) {
      return null;
    }
    return WarpApi.getTAddr(coin, acc.id);
  }

  static List<String>? allAddressesForAccount(final int accountId) {
    final acc = rotationAccounts[accountId];
    if (acc == null) {
      printV("Nothing found");
      return null;
    }
    for (int i = 0; i < acc.length; i++) {
      final b = WarpApi.getBackup(coin, acc[i].id);
      printV("$i. ${b.seed?.split(" ").last}, ${b.index}, ${WarpApi.getTAddr(coin, acc[i].id)}");
    }
    return acc.map((final a) => WarpApi.getTAddr(coin, a.id)).toList();
  }

  static List<String>? allUsedAddressesForAccount(final int accountId) {
    final seed = WarpApi.getBackup(coin, accountId).seed!;
    final acc = rotationAccounts[seed]?.toList();
    if (acc == null) {
      printV("Nothing found");
      return null;
    }
    acc.removeWhere((final a1) {
      for (int i = 0; i < (rotationAccountsUsable[seed]?.length ?? 0); i++) {
        if (rotationAccountsUsable[seed]?[i].id == a1.id) {
          return true;
        }
      }
      return false;
    });
    for (int i = 0; i < acc.length; i++) {
      final b = WarpApi.getBackup(coin, acc[i].id);
      printV("$i. ${b.seed?.split(" ").last}, ${b.index}, ${WarpApi.getTAddr(coin, acc[i].id)}");
    }
    return acc.map((final a) => WarpApi.getTAddr(coin, a.id)).toList();
  }
}
